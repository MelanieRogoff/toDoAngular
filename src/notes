Tutorial Notes: 

Tutorial #1: Folder Structure
---------------------------------------------

**CAN RESET PORT BY DOING ng serve --port=4300**

1.e2e:
    -where our end-to-end test scripts live. 
    -has protractor.conf.js - Protractor framework runs end to end tests
    -app.po.ts = Protractor file that'll have "po" file (po is how we know it's Protractor file)
    -app.e2e-spec.ts file:
        -e2e tells the script that it's end to end test script
        -spec means it's a test file

2. node_modules:
    -ng new appNameHere makes a new node_modules
    -folder where all modules/libraries live
    - use: npm i nameHere to install a library. Ex: npm i bootstrap
    - DON'T TOUCH THIS FOLDER FOR DEVELOPMENT PURPOSES. 

3. src (most critical):
    -where our app resides
    - Basic Structure:
        a. app folder (where we see components, modules, services, directives, pipes)
            i. app.component.ts, app.component.html, etc
            ii. app.component.spec.ts file [means it's a UNIT TEST script/file, NOT end to end]
        b. assets
            -styles
            -icons
            -images
        c. environments (configure variables or pipelines for dev, staging, test, prod)

        d. polyfills - if user browser is outdated, polyfills will add the functionality to it to make it backwards compatible

        e. main.ts - boots up the application

        f. styles.css - global stylesheet. Use limited things such as fonts/typography. Have specific styling in respective component css files

4. test.ts - test script for booting process. All the code for main.ts is tested HERE.

5. angular.json - has the configuration for our entire project 
        
6. karma.conf.js - runs unit test scripts

7. tsconfig.json - build & compilation related to our angular app

8. tslint.json - linting/coding standards we can set

9. package.json
    -can customize the scripts and add new scripts
    - GO HERE 1ST TO UNDERSTAND ANY ANGULAR PROJECT YOU JOIN/EXISTING APPLICATION

10. package-lock.json
    -contains everything needed to run in prod mode - CRITICAL TO HAVE
    -resolves all required sub modules

**bootstrapModule loads and initializes browser application**

**use ng test to run Jasmine unit tests**

**use ng e2e to run all our end to end tests**

**use ng update if you run on any version less than current/desired version**

**use ng build to build/generate the output of our app. It's compiled JS code**

**use ng lint to see what code passes the syntax linting. Can set coding standards & rules**

-----------------------------------------------------------------------
Tutorial #2: Modules
-----------------------------------------------------------------------
1. Contains multiple components, can contain services, directives, pipes related to a particular functionality -- basically a logical grouping

2. In modules (ex: AppModule), we do the following:

    -declarations: enter components we're using here, as well as pipes
    -imports: enter modules we're going to use here
    -providers: enter any services we use here
    -bootstrap: tells angular which component to start with

3. Make a new module by doing: ng generate module todo, for example. 
    -MUST import it into AppModule

-----------------------------------------------------------------------
Tutorial #3: Decorators
-----------------------------------------------------------------------
1. TS feature used for passing metadata

2. Functions that return functions; invoked @ run time

3. Types of Decorators:
    A. Class Decorators: @NgModule, @Component
    B. Property Decorators: @Input, @output -- ex: @Input() data: string;
    C. Method/Event Decorators: @HostListener
    D. Parameter Decorators: @Inject

4. Start with @ symbol

-----------------------------------------------------------------------
Tutorial #4: Components
-----------------------------------------------------------------------
1. Basically little pieces that can be reused throughout the app in multiple places.

2. Smaller feature/functionality inside of a bigger functionality

3. Tree Hierarchy:
         Parent
    Child1, Child2, Child3

4. <app-root> = 1st component that gets loaded. You see this in app.component.html

5. AppComponent = MOST IMPORTANT COMPONENT. Its selector is <app-root>

6. Each component will have 3 important things:
    -selector
    -templateUrl or template
    -stylesUrl

7. To make a component, do: ng g c componentName. It'll add the component name automatically to our AppModule for us

8. Where you generate the component is CRITICAL bc the parent module will be updated accordingly with the new component

9. We can have components inside of components (sub components). We do this by taking the selector name and putting it in a component html file as an element. 
    -Ex: we put our <app-tasks> inside of AppComponent by putting, in app.component.html: <app-tasks></app-tasks>

10. We can import our components by importing the corresponding module into AppModule.

11. Need to do export: [ComponentHere] in order to use it when importing a module that corresponds to it

-----------------------------------------------------------------------
Tutorial #5: Directives (like a class)
-----------------------------------------------------------------------
1. 3 Types of Directives:

    A. Component 
        -Every app needs at least 1 component
        - Have their own templates
        - Events attached

    B. Structural
        -ALWAYS STARTS WITH *
        -(*) Symbol
        -Updates structure of the template/elements of the template
        -*ngFor, *ngIf, *ngSwitch

    C. Attribute 
        -Changes the styling property
        -ngStyle, ngClass 
            -Ex: [ngStyle]='{color: colorName}' <-- Define the colorName in the ts file

2. ngIf is if/else (can show/hide using this)

3. ngSwitch is switch case

4. To make a directive, do: ng generate directive directiveName

-----------------------------------------------------------------------
Tutorial #6: *ngIf
-----------------------------------------------------------------------
1. Built-in STRUCTURAL Directive that can add/remove elements

2. Resolves to true or false (is boolean)

3. Example:
    <div *ngIf="condition"></div>

4. Else statement in *ngIf will show the block based on the false condition

5. **FOR USING ELSE, USE <ng-template> & PASS A TEMPLATE REFERENCE VARIABLE W/It
    Ex: 
        <div *ngIf="showValue; else showMessage">Show Message</div>
        <ng-template #showMessage>Show the else message</ng-template>

6. CANNOT DEFINE THE TEMPLATE REFERENCE VARIABLE W/ANYTHING OTHER THAN NG-TEMPLATE

7. *ngIf with Then AND Else statement
    -When condition is true, use the template variable reference, and THEN block will be exectued
    -When condition is false, use the template variable reference, and ELSE block will be exectued
    -Ex:
        <div *ngIf="showValue then thenBlock; else showMsg">Show value</div>
        <ng-template #thenBlock>Showing THEN Message</ng-template>
        <ng-template #elseBlock>Showing ELSE Message</ng-template>

-----------------------------------------------------------------------
Tutorial #7: *ngSwitch
-----------------------------------------------------------------------
1. Built-in STRUCTURAL Directive that can add/remove elements

2. Allows element to be shown/hidden based on a condition

3. Can take MULTIPLE value params for a condition check

4. We also define a default action

5. 3 Important Elements of *ngSwitch:
    A. *ngSwitch
    B. *ngSwitchCase
    C. *ngSwitchDefault

6. Ex: 
    <div [ngSwitch]="switchExpressionHere>
        <div *ngSwitchCase="meetsExpression1Criteria">...</div>
        <div *ngSwitchCase="meetsExpression2Criteria">...</div>
        <div *ngSwitchCase="meetsExpression3Criteria">...</div>
        <div *ngSwitchDefault>...</div>
    </div>

7. Can pass any value type - integer, string, etc

8. Can read the value dynamically

9. REMEMBER TO PUT * BEFORE THE NG

10. For STRING VALUES, put '' inside the ""

-----------------------------------------------------------------------
Tutorial #8: *ngFor
-----------------------------------------------------------------------
1. Like a for statement

2. Built-in STRUCTURAL directive -- modifies the DOM structure

3. Loops through elements to display array data in the template

4. Ex:
    <div *ngFor="let el of collection"></div>

5. Can be used with any element, not just <div>

6. Provides local variables in the array data. 

    A. Index -- this gets the CURRENT index of the CURRENT element in the iteration
        i. Index starts with 0
        ii. VERY important for whenever we do DOM manipulation
        ii. Ex: 
            <div *ngFor = let el of elements; index as i;"></div>
    
    B. First -- gives true or false if it's the first element
        i. Ex:
            <div *ngFor="let el of elements; index as i; first as f;"></div>
    
    C. Last -- gives true or false if it's the last element
        i. Ex:
            <div *ngFor="let el of elements; index as i; first as f; last as l;"></div>

    D. Even -- gives true or false if it's an even element
        i. Ex:
            <div *ngFor="let el of elements; index as i; first as f; last as l; even as e;"></div>

    E. Odd -- gives true or false if it's an odd element
        i. Ex:
            <div *ngFor="let el of elements; index as i; first as f; last as l; odd as o;"></div>

-----------------------------------------------------------------------
Tutorial #9: ngStyle
-----------------------------------------------------------------------
1. ATTRIBUTE directive that lets us set a given DOM element (such as a <div> or <li>)'s style properties

2. Can pass dynamic values via variables

3. Ex (NON DYNAMIC):
        <div [ngStyle]="{'color': 'red'}">Example</div>
        ^^passing the CSS property (ex: background-color, color), followed by the value
   
   Ex (DYNAMIC):
        <div [ngStyle]="{'color': colorValue}">Here is an example of ngStyle</div>
        (we set the colorValue value in the corresponding ts file)

4. We can set 1+ properties via ngStyle
    Ex: 
        <div [ngStyle]="{'color': colorValue, 'background-color': bgColorValue }"Example</div>
        (we set the colorValue and bgColorValue values in the corresponding ts file)

-----------------------------------------------------------------------
Tutorial #10: ngClass
-----------------------------------------------------------------------

1. ATTRIBUTE directive that lets us set the class name for DOM elements. 
    [ngClass]="" <--example. When passing a string in, use '' within ""

2. Can pass dynamic values via variables    
    - strings, arrays, objects, component Method

3. Examples:
    <div [ngClass]="one">First example</div>
    <div [ngClass]=" { 'one': true, 'two': false } ">Multiple class name example</div>

5. Dynamic example: 
    <div [ngClass]="variableName">Dynamic</div>

    TO PASS MULTIPLE CLASSES, WE CAN USE AN ARRAY:

    <div [ngClass]="[clsName, clsName2]">Example</div>

6. We can use expressions to evaluate the classes. Example:

    <div [ngClass]=" { 'one': true, 'two': false } "></div>

    By doing the above, we apply the 'one' class if true, else (if it's false), apply the 'two' class.

-----------------------------------------------------------------------
Tutorial #11: Data Binding (ALL EXAMPLES WILL BE IN THE data-binding-tutorial-section COMPONENT)
-----------------------------------------------------------------------

1. Data Binding allows us to BIND the data from the view (Template) to the Controller (Component class) and vice versa

2. Data Binding (interacting with data) defines HOW the data flows & gets updated, based on our business logic (which is returned in our Component class). 
    --Business Logic is referred to as the Component class (ex: app.component.ts).

3. Every component will have a template (view) & component, so we need data that flows both ways

4. 2 Types of Data Binding:

    A. One-Way Data Binding (one at a time)
        i. This is Component-to-View
            -We can accomplish this via:
                -Interpolation {{ example here }}
                    -Displays the data from Component to View (HTML file)
                -Property Binding
                -Style Binding
                -Attribute Binding
        
        ii. This can also be View-to-Component (from Template/HTML to Component)
            -We can accomplish this via EVENT Binding (EX: onKeyUp, onKeyDown).

    B. Two-Way Data Binding 
        i. Data flows from View-to-Component AND from Component-to-View all at once
            -Use ngModel for this

-----------------------------------------------------------------------
Tutorial #12: One-Way Data Binding (INTERPOLATION ONLY)
-----------------------------------------------------------------------

1. Interpolation allows the user to bind data from COMPONENT TO VIEW/TEMPLATE/HTML

2. The data flow here is ONE-WAY ONLY (from Component to View)

3. This can be used for number/integers, strings, objects, arrays, and more.

4. Syntax is {{ variableName }}

5. ALL EXAMPLES WILL BE IN THE data-binding-tutorial-section COMPONENT

-----------------------------------------------------------------------
Tutorial #13: One-Way Data Binding (PROPERTY BINDING ONLY)
-----------------------------------------------------------------------

1. Property Binding allows the user to bind properties of elements from COMPONENT TO VIEW(TEMPLATE/HTML)

2. The data flow here is ONE-WAY ONLY (from Component to View)

3. This can be used for all properties, such as innerHTML, src, etc.

4. Syntax is [propertyName]="'expressionHere'"

5. ALL EXAMPLES WILL BE IN THE data-binding-tutorial-section COMPONENT

-----------------------------------------------------------------------
Tutorial #14: One-Way Data Binding (ATTRIBUTE BINDING ONLY)
-----------------------------------------------------------------------

1. Attribute Binding allows the user to bind ATTRIBUTES of elements from COMPONENT TO VIEW(TEMPLATE/HTML)

2. The data flow here is ONE-WAY ONLY (from Component to View)

3. This can be used for ANY EXISTING PROPERTIES OR CUSTOM ATTRIBUTES

4. Syntax for defining Attribute Binding: 
    [attr.attributeName]="'expressionHere'"

5. ALL EXAMPLES WILL BE IN THE data-binding-tutorial-section COMPONENT

-----------------------------------------------------------------------
Tutorial #15: One-Way Data Binding (EVENT BINDING ONLY)
-----------------------------------------------------------------------

1. Event Binding allows the user to bind EVENTS of elements from COMPONENT TO VIEW(TEMPLATE/HTML)

2. The data flow here is ONE-WAY ONLY (from Component to View)

3. This can be used for ALL AVAILABLE EVENTS

4. Syntax for defining Event Binding: 
    <button (eventName)="function()"></button>
  
5. Some events include: onKeyUp, onHover, onKeyDown, etc
    
6. ALL EXAMPLES WILL BE IN THE data-binding-tutorial-section COMPONENT

-----------------------------------------------------------------------
Tutorial #16: Two-Way Data Binding (EXAMPLE IN two-way-data-binding component)
-----------------------------------------------------------------------

1. Allows the user to bind EVENTS of elements from COMPONENT TO VIEW(TEMPLATE/HTML)

2. The data flow here is BOTH WAYS (from View to Component & from Component to View)

3. Two-Way Data Binding is a COMBINATION of Property Binding & Event Binding

4. In this type of data binding, we use ngModel  
    -MUST IMPORT { FormsModule } INTO YOUR app.module.ts IN ORDER TO USE ngModel

5. Syntax:
    <input [(ngModel)]='data'/>
      
6. ALL EXAMPLES WILL BE IN THE two-way-data-binding COMPONENT

-----------------------------------------------------------------------
Tutorial #17: Pipes (EXAMPLES IN pipes-tutorial component)
-----------------------------------------------------------------------

1. Pipes are used to TRANSFORM data

2. Pipes take data input and convert/transform that data into a desired format

3. Pipes are written by using the pipe operator, which looks like this: |

4. Can apply pipes to ANY View(Template/HTML), and to ANY data inputs

5. Types of Pipes:
    A. Built-In Pipes
        -Lowercase
        -Uppercase
        -Currency
        -Date
        -JSON

    B. Parameterized Pipes
        -We can pass 1+ params to pipes (can override values this way)

    C. Chaining Pipes 
        -We can connect MULTIPLE pipes to a data input

    D. Custom Pipes 
        -We can create our own custom pipes for various data formatting

-----------------------------------------------------------------------
Tutorial #18: Parameterized Pipes (EXAMPLES IN pipes-tutorial component)
-------------------------------------------------------------------------

1. Parameterized Pipes are ones that can take a parameter. 

2. We can pass parameters by using :

3. Currency pipe can take the following params:
    A. Currency symbol
    B. Currency code
    C. Currency Digit Variations

4. Date pipe can take the following params:
    A. 'short' ('M/d/yy, h:mm a', otherwise known as 6/15/15, 9:03AM)
    B. 'medium' ('MMM d, y, h:mm:ss a', June 15 2015, 9:03:01 AM)
    C. 'long' ('MMMM d, y, h:mm:ss a z', June 15 2015 at 9:03:01 AM GMT+1)
    D. 'full' ('EEEE, MMMM d, y, h:mm:ss a z', Monday, June 15, 2015 at 9:03:01 AM GMT+01:00)
    F. 'shortDate' ('M/d/yy', 6/15/15)
    G. 'mediumDate' ('MMMM d, y', June 15, 2015)
    H. 'longDate' ('MMMM d, y', June 15, 2015)
    I. 'shortTime' ('h:mm a', 9:03 AM)
    J. 'mediumTime' ('h:mm:ss a', 9:03:01 AM)
    K. 'longTime' ('h:mm:ss a z', 9:03:01 AM GMT+1)
    L. 'fullTime' ('h:mm:ss a zzzz', 9:03:01AM GMT+01:00)

-----------------------------------------------------------------------
Tutorial #19: Chaining Pipes (EXAMPLES IN pipes-tutorial component)
-----------------------------------------------------------------------

1. Chaining Pipes is simply the act of using multiple pipes on a data input.

2. We can pass 1+ pipes to a data input (usually chain 2-3 pipes max). 
    - Ex: {{ dataInputName | date | uppercase }}
        --In the above, the date pipe gets applied FIRST, then uppercase. 
        --The pipes run left-to-right.

-----------------------------------------------------------------------
Tutorial #20: Custom Pipes (EXAMPLES IN highlight-pipe-tutorial PIPE FILES & custom-pipe-example component)
-----------------------------------------------------------------------

1. Generate via CLI by running:
    ng generate pipe pipeName

2. Pipes MUST be added to the module, which the CLI does automatically

3. We need to manually import Pipe and PipeTransform from '@angular/core'

4. Pipes are declared with the @pipe decorator and provide the selector name.

-----------------------------------------------------------------------
Tutorial #21: Routing
-----------------------------------------------------------------------

1. Router Module has everything needed for designing, developing, and implementing routes/navigation links

2. There can only be ONE instance of the router in our Angular app

3. Router module is found in '@angular/router'.

4. Must set up the Router array - every time a request is made, the router will search in the list of the array and find the most relevant match. 

5. Router has states, which helps us get info about the current state & data related to routes

6. Router can handle & configure these types of routes:
    -Routes for components
    -Getting Query Params from routes
    -Getting URL segments
    -Loading child routes for a module
    -Lazy Loading
    -Handling wild card routes
    -Handling default routes
    -Handling 404 routes

7. We navigate FROM ONE COMPONENT VIEW TO ANOTHER via routes

8. Example of Routes array:
    const routes: Routes = [
        { path: '', redirectTo: 'enroll', pathMatch: 'full' },
        { path: '*', redirectTo: 'enroll', pathMatch: 'full'},
    ];

-----------------------------------------------------------------------
Tutorial #22: Routing Plan & Routing Strategy
-----------------------------------------------------------------------

1. Before we implement our routes, we plan the Routing Strategy, which determines the entire app flow & navigation.
    -Example:
        /products
        /product/10
        /product/10/details
        /product?search=param1
        /home
        /dashboard
        /search?keywords=k1 <-- query

2. 2 Types of Routing Strategies:
    A. PathLocationStrategy
    B. HashLocationStrategy

        --We would add these in the Providers of our Module, like this:
            { 
                provide: LocationStrategy, 
                useClass: HashLocationStrategy
            }
    
3. BY DEFAULT, Angular uses PathLocationStrategy (/products, /home).

4. With HashLocationStrategy, we see the # in the URL (/#/products, /#/products/10, /#/home).

-----------------------------------------------------------------------
Tutorial #23: Routing - Base HREF
-----------------------------------------------------------------------

1. Every Angular app has a MANDATORY base HREF

2. Angular apps are SPA (Single Page Architecture), meaning there will be only ONE HTML FILES

3. Default base HREF is set to '/', which is the ROOT folder

4. The base HREF is present in index.html for ALL Angular apps

    -This is in the index.html:
          <base href="/">

5. When we run 'ng build', Angular assumes that we are deploying to the root folder

6. We configure it by doing: 

    ng build --base-href="/basePathName/"

-----------------------------------------------------------------------
Tutorial #24: Routing - Router Module
-----------------------------------------------------------------------

1. Routing Module is the placeholder for configuring all routes & navigations in one module

2. Make sure ALL ROUTES ARE CONFIGURED IN ONE PLACE

3. Generate the app routing module using the CLI by running:

    ng generate module app-routing --flat -module=app

4. The file for the Router Module is: app-routing.module.ts. 

5. Here are the steps outlining what is required in the Router Module file:
   
    1. Import NgModule from '@angular/core'

    2. Import { Routes, RouterModule } from '@angular/router'

    3. Create an array of routes
        -EX:
            const routes: Routes = [
                { path: '', redirectTo: 'enroll', pathMatch: 'full' },
                { path: '*', redirectTo: 'enroll', pathMatch: 'full'},
            ];

    4. Use the @NgModule decorator to import the RouterModule & export it
        - EX: 
            @NgModule({ // RouterModule.forRoot tells Angular to make it available throughout the app
                imports: [RouterModule.forRoot(routes)],
                exports: [RouterModule]
            })

    5. Export the entire class.
        -EX: 
            export class AppRoutingModule { }

    6. Import the AppRoutingModule into app.module.ts

-----------------------------------------------------------------------
Tutorial #25: Routing - Router Outlet
-----------------------------------------------------------------------

1. Router Outlet is a Directive from Router Module.

2. Every Angular app MUST have Router Outlet.

3. We can have 1+ Router Outlets in our apps
    -We can specify named Router Outlets in our app

4. Router Outlet lets us define WHERE output should be displayed

5. Router Outlet can be specified at App Module or in individual modules

6. We can see Router Outlet @ bottom of our app.component.html file.
    - EX: 
        <router-outlet></router-outlet>

7. PUT A <router-outlet> WHEREVER WE WANT THE OUTPUT TO DISPLAY FOR A ROUTE. 

    -This means it can be in a different HTML file as well. But it's best to just have it in app.component.html

-----------------------------------------------------------------------
Tutorial #26: Routing - Configuring Routes
-----------------------------------------------------------------------

1. We can configure routes to redirect routes for various paths, including:
    A. Path
    B. Component
    C. redirectTo
    D. Children

2. This means adding routes into our Routes array in our app-routing.module.

3. We give the path, then the component that should display. 
    -EX: 
        { path: '*', component: DisplayEverythingComponent }

-----------------------------------------------------------------------
Tutorial #27: Routing - Parameterized Routes
-----------------------------------------------------------------------

1. We can send parameters to our routes

2. To configure a route with a dynamic value, we would pass a paramter, like so:
    -EX: 
        { path: 'product/:id', component: ComponentName }
    
    With :id above, if we look up product/10, product/20, etc, it'll work because of the :id

-----------------------------------------------------------------------
Tutorial #28: Routing - Query Parameters
-----------------------------------------------------------------------

1. Query params are passed in the URL route (after the '/') like this:
    EX: 
        search?keyword=food&country=usa

2. These are usually GET calls.

3. These are visible to the end users, so make sure to NOT put any sensitive information in the query params.

4. We inject ActivatedRoute in the ts file to capture the query params.
    EX: 
        If we have a file called search.component.ts, we do the following:
            constructor(private activatedRoute: ActivatedRoute) { //Inject ActivatedRoute in the constructor
                this.activatedRoute.queryParams.subscribe(data => {//subscribe to the data from the queryParams in the ActivatedRoute
                    //INSERT CODE HERE
                })
            }
-----------------------------------------------------------------------
Tutorial #29: Routing - Redirecting Routes
-----------------------------------------------------------------------

1. When we want a route to be redirected to another route, we add a redirectTo in our Routes array.

2. Syntax:
    { path: '', redirectTo: 'home', pathMatch: 'full' }

3. We don't use component: ComponentName, because we are redirecting instead.

4. The empty path in the above example indicates that it's the DEFAULT ROUTE of the app. 
    -It also requires us to mention that the pathMatch should be 'full'. 

5. path: '' is the default route. MUST ALWAYS HAVE pathMatch: 'full' with default route in order for it to work.

-----------------------------------------------------------------------
Tutorial #30: Routing - Wildcard Routes
-----------------------------------------------------------------------

1. Wildcard Routes intercept any invalid URLS in our app.

2. When there are NO MATCHING ROUTES in the Routes array, the router doesn't know where to go. 
    - This results in errors; to avoid this, do:
        { path: '**'}

3. Best Practice: Creating a component called PageNotFound and mapping it to the Wildcard RouterModule
    EX: 
        { path: '**', component: PageNotFound }

4. BAD IDEA TO HAVE MORE THAN ONE WILDCARD ROUTE!

-----------------------------------------------------------------------
Tutorial #31: Routing - Child Routes
-----------------------------------------------------------------------

1. Child Routes let us configure URL segments that are logically related in at least one way. 

2. Syntax involves defining the parent routes first, then the children:
    -EX: 
        { path: 'products',
            children: [
                { path: 'product-child', component: ProductViewComponent }
            ]
        }

3. We can make ANY number of child routes to a parent route

4. Example of different child route names:

    -If we start with 'customers', which is the same as '/customers' (PARENT ROUTE), we can:
        -Have view (with info, gallery, details), edit, and delete 
        - These would go UNDER the 'customers' tree, so to speak, and look like this:

            For View: 
                www.namehere.com/customers/view

                -Info within View:
                    www.namehere.com/customers/view/info

                -Gallery within View:
                    www.namehere.com/customers/view/gallery

                -Details within View:
                    www.namehere.com/customers/view/details
            
            For Edit:

            For Delete:
            
5. Not the best method, however - create a separate module for Customers in this case

-----------------------------------------------------------------------
Tutorial #32: Routing - Lazy Loading
-----------------------------------------------------------------------

1. By default, NgModules are EAGERLY loaded, meaning that all NgModules load as soon as the app loads, even if they're not immediately needed. 

2. When we have a large app with many routes, we use Lazy Loading, which means ONLY loading the NgModules as they are needed. 

3. Lazy Loading keeps initial bundle sizes smaller, and decreases load time. This is a good thing!

4. With Angular 8, loadChildren expects a function that uses the dynamic import syntax in order to import your lazy-loaded module only when it's needed. 
    EX: 
      { path: 'orders', loadChildren: () => import('./orders/orders.module').then(m => m.OrdersModule) }, //imports from the orders.module and then loads this OrdersModule

5. To create a Lazy Loading Feature Module: 
    i. Create Feature Module (module SPECIFIC to a certain functionality)
    ii. Configure loadChildren in appRouting.

6. To load a feature module lazily (or on demand), we load its children using ther loadChildren property in route configuration. 

7. Lazy Loading Creation Syntax:
    ng g module lazyLoadName --route lazyLoadName --module app.module
        ^This says to generate a module with the name lazyLoadName
            Create a Lazy Loading Feature module with the lazyLoadName path 
                Then update that in the app.module
    
8. Every Feature Module has its own child routes. 
    EX: customer is a Feature Module 
        -It has the following example children: views, orders, history

9. When we generate the Lazy Loaded module, it is NOT loaded by default. 
    -We can see this in the Network tab in DevTools

10. We can see the Lazy Loaded module in the Network tab in DevTools IF we go to the specific path the module is tied to

11. WE ONLY LOAD THE LAZY LOADED (FEATURE) MODULE IF WE CALL IT (GO TO THE PATH THAT USES IT).

-----------------------------------------------------------------------
Tutorial #33: Routing - Route Guards
-----------------------------------------------------------------------

1. Route Guards PREVENT users form navigating to parts of the app that they are not authorized to enter. 

2. Route Guards are used to secure route paths. 

3. Route Guards resolve (give/return) to true or false based on custom logic/functionality

    -Based on the boolean value (true/false), Angular Router decides if the user should access the route or not. 

4. We can make any number of Route Guards. 

5. To create a Route Guard, do:
    ng generate guard guardName

6. We inject our guard in our module under providers. 
    EX: 

7. Route Guard Types (Interfaces) Available: 
    A. CanActivate -- checks to see if a user can visit a route (will activate that component)
    B. CanActivateChild -- checks to see if a user can visit a route's children
    C. CanDeactivate -- checks to see if a user can leave a route
    D. Resolve -- performs route data retrieval BEFORE route activation
    E. CanLoad -- checks to see if a user can route to a module that is lazily loaded

    THESE ALL RESOLVE TO TRUE OR FALSE BASED ON THE LOGIC/FUNCTIONALITY WE USE.

8. Example of a Route Guard implementation:
  { path: 'admin', component: AdminHomeComponent, canActivate: [AdminGuardGuard] },
    ^^ This says that when the path is admin, we'll use AdminHomeComponent.
       It can ONLY activate based on the info in the AdminGuard we created. 
       Essentially, whenever AdminGuardGuard resolves to TRUE, let the user access the admin path and display the AdminHomeComponent. 
       When it's false, DO NOT LET THE USER VIEW THIS DATA. 
 
 -----------------------------------------------------------------------
Tutorial #34: Forms
-----------------------------------------------------------------------

1. There are 2 Types of Forms:
    A. Template-Driven
    B. Reactive (Dynamic)

2. We have Two-Way Data Binding, Change Tracking, Validations, Error Handling, and Unit Testing available for Forms.

3. Template-Driven Forms:
    - Easy to use
    - Simple/straightforward
    - All validations & form elements are defined in the template file
    - Must import FormsModule in app.module.ts
    - USE IF: 
        Your forms are simple & straightforward
        Your forms have FIXED static form fields & elements
        Your forms have NO COMPLEX VALIDATIONS OR PATTERN MATCHING
    
    -EX: Contact Form

4. Reactive (Dynamic) Forms:
    -All form elements, user interactions, and validations are handled in the component class
    - Can use formGroup & formControl
    - Can control better data binding
    - Can define custom regular expression patterns of error handling
    - Must import ReactiveFormsModule into app.module.ts
    - Allows users to define & develop complex Forms
    - More logic is in the component class - less logic in the HTML markup.
    -USE IF: 
        Your forms are complex 
        Your forms use multiple dynamic components
        Your forms have advanced validation requirements
        Your forms have dependent form elements

    -EX: Checkout Order Form

-----------------------------------------------------------------------
Tutorial #35: Template-Driven Forms
-----------------------------------------------------------------------

1. These forms are tracked automatically

2. Uses Two-Way Data Binding 

3. Most of the code is in the HTML/Template file -- NOT the Component class

4. Tracked form data traverses via various states (such as pristine, dirty, etc)

5. Unit testing is more difficult with this

6. Two variables unique to Template-Driven Forms:

    A. ngForm (form name as a template variable - ex: #templateName)
            <form #signInForm="ngForm" (ngSubmit)="loginUser(signInForm)"> // This says on submit we call the loginUser method and pass the form name into it

    B. ngModel (every form field should have a name attribute & ngModel attached to it)
        EX: 
          <input type="email" name="emailAddress" ngModel>

7. Remember to ALWAYS import FormsModule in app.module FIRST. 
    -After doing this, we create the form in app.component.html, for example.
        -Use ngForm and ngModel (see #6 for definitions and example code)

-----------------------------------------------------------------------
Tutorial #36: Template-Driven Forms - Validation
-----------------------------------------------------------------------

1. Angular provides validators such as minLength, maxLength, and required.

2. Angular maintains state information of the Forms at all times. 
    -Examples of such states are:
        A. ng-touched
        B. ng-untouched
        C. ng-dirty
        D. ng-pristine
        E. ng-valid
        F. ng-invalid 

3. Ways to Handle Validation in Template-Driven Forms:
    A. Highlight the errors 
        -Ex: 
            input.ng-invalid.ng-touched {
                background-color: red;
            }

    B. Disable the Submit button
        -This is done by adding the following:
            [disabled]="!formName.valid"

    C. Custom Field Level Validation - Show/Hide Error Messages
        -Ex:
            <span *ngIf="firstname.touched && !firstname.valid">Please enter your email.</span>

-----------------------------------------------------------------------
Tutorial #37:  Reactive Forms
-----------------------------------------------------------------------

1. All form elements, user interactions, and validations are handled in the component class

2. We use formGroup & formControl

3. Reactive Forms allow for better data binding

4. We can define custom regular-expression patterns for error handling

5. FIRST STEP IS IMPORTING ReactiveFormsModule INTO app.module.ts

6. Angular maintains state information of the Reactive Forms at all times
    A. ng-touched
    B. ng-untouched
    C. ng-dirty
    D. ng-pristine
    E. ng-valid
    F. ng-invalid

Because Reactive Forms can be more complex, we are going to follow 5 Steps:

    STEP 1: Import ReactiveFormsModule into app.module.ts

    STEP 2: Create the form in your component.html file
        -FormGroup (directive for the entire form)
        -formControlName (every form field should have a "formControlName" attribute)

        -EX: 
            <form [formGroup]="registerForm" (ngSubmit)="postData()">
                <input type="text" formControlName="fname">    
                <input type="text" formControlName="email">    
                <input type="submit" value="Post Data" [disabled]="!registerForm.valid">    
            </form>

    STEP 3: In the component class, import the FormBuilder, FormGroup, FormControl NgForm, and validators

    STEP 4: Inject the FormBuilder in the constructor in the component class    
       
        EX: 
            constructor (private formBuilder: FormBuilder ) {}

    STEP 5: Create the form instance

        EX: 
            this.registerForm = formBuilder.group({
                fname: new FormControl(),
                lname: new FormControl()
            });
-----------------------------------------------------------------------
Tutorial #38:  Reactive Forms -- Validations
-----------------------------------------------------------------------

1. Angular provides validators such as minLength, maxLength, and required.

2.  Ways to Handle Validation in Responsive Forms:
    A. Highlight the errors 
        -Ex: 
            input.ng-invalid.ng-touched {
                background-color: red;
            }

    B. Disable the Submit button
        -This is done by adding the following:
            [disabled]="!formName.valid"

    C. Custom Field Level Validation - Show/Hide Error Messages
        -Ex:
            <span *ngIf="firstname.touched && !firstname.valid">Please enter your email.</span>

-----------------------------------------------------------------------
Tutorial #39:  Reactive Forms -- Get Values
-----------------------------------------------------------------------

1. We can get values of a form field/control from the form

2. Syntax for reading the value of the entire form:

    this.formName.value

3. Syntax for reading the value of an INDIVIDUAL form control:

    this.formName.get('fieldName').value

-----------------------------------------------------------------------
Tutorial #40:  Reactive Forms -- Set Values
-----------------------------------------------------------------------

1. We set the values of the entire form by using setValue().

2. We need to set values for every field of the form.

3. We CANNOT omit any field in the form.

4. Syntax for setValue(): 

    this.registerForm.setValue({
        fname: 'Me',
        lname: 'Hello',
        email: 'email@gmail.com'
    });

5. We set INIDIVUDAL field values by using patchValue()

6. Syntax for patchValue():

        this.registerForm.patchValue({
            fname: 'New',
            email: 'another@gmail.com'
        })

-----------------------------------------------------------------------
Tutorial #41:  Reactive Forms -- Reset Forms
-----------------------------------------------------------------------

1. Must reset our forms to avoid duplicate values from being added

2. We can reset the entire form by using reset()
    Syntax:
        this.registerForm.reset()

-----------------------------------------------------------------------
Tutorial #42:  Reactive Forms -- valueChanges
-----------------------------------------------------------------------

1. valueChanges is an important property of FormControl, FormGroup, and FormArray.

2. valueChanges RETURNS an Observable

3. We need to SUBSCRIBE to that Observable in order to read the value. 

4. valueChanges is a property in AbstractControl

5. valueChanges emits an event everytime there's a change in the value of the controls

6. Two Approaches for valueChanges:

    A. For Form Controls (on an individual Form Control)
        -When subscribed to the observable, we will get the LATEST changed value
        -Syntax:
            this.formName.get('email').valueChanges.subscribe(data => {
                console.log(data);
            })

    B. For ENTIRE Form
        -When subscribed to the observable - we get the ENTIRE FORM, BUT the values will ONLY be for the changed Form Control

        -Syntax:
            this.formName.valueChanges.subscribe(data => {
                console.log(data);
            })

-----------------------------------------------------------------------
Tutorial #43:  Reactive Forms -- statusChanges
-----------------------------------------------------------------------

1. statusChanges is an important property of FormControl, FormGroup, and FormArray.

2. statusChanges RETURNS an Observable

3. We need to SUBSCRIBE to that Observable in order to read the value. 

4. statusChanges is a property in AbstractControl

5. statusChanges emits an event everytime there's a change in the VALIDATION STATUS OF THE CHANGED CONTROLS

6. Multiple Approaches for statusChanges:
    
    A. For Form Controls
        -When subscribed to the Observable, WE GET THE VALIDATION STATUS OF THE CONTROLS
        -Syntax:
            this.formName.get('fname').statusChanges.subscribe(data => {
                console.log(data);
            })

    B. For the Entire Form
        -When subscribed to the Observable, we GET THE VALIDATION STATUS OF THE ENTIRE FORM
        -Syntax:
            this.formName.statusChanges.subscribe(data => {
                console.log(data);
            })

-----------------------------------------------------------------------
Tutorial #44:  Reactive Forms -- Form Array
-----------------------------------------------------------------------

1. Form Arrays are needed for complex forms. 

2. Form Arrays allow us to easily remove and add elements. 

3. Form Array tracks the value & validity state of an array of FormCtrols, Form Arrays and FormGroup

4. Form Array aggregates the values of the "child" FormControl into an array

5. The status of the FormArray is calculated by reducing the statuses of its children.

6. If one of the controls are invalid, the ENTIRE array will be invalid.

7. A Form Array can be an array of FormGroups, of FormGroups, or both.
    -In other words, for a Form Array to be valid, ALL of the FormControls/FormGroups/etc IN the array must be valid

8. Use Cases for Form Arrays:

    A. Creating a Form w/simple array items
        -EX: 
            this.checkoutForm = formBuilder.group({
                items: this.formBuilder.array([
                    new FormControl('HI'),
                    new FormControl('HELLO'),
                    new FormControl('LEARNING'),
                    new FormControl('CODING')
                ])
            });

        In the Template (HTML) file, we would then LOOP through the values & display them:
            <div class="col-sm-10" formArrayName="items">
                <div *ngFor="let control of checkoutForm.controls.items['controls']; let i=index;">
                    <input type="text" [formControlName]="i" id="learn{{i}}">
                </div>
            </div>


    B. Getting the properties and methods of the array
        -EX: 
            console.log(myArr.value);
            console.log(myArr.status);
            console.log(myArr.length);
            console.log(arr.setValue(['name', 'last name']));
            console.log(arr.patchValue(['name', 'last name']));
            console.log(arr.reset(['name', 'last name']));
            console.log(myArr.clear());

    C. Reactive Form with array items and other FormControls
        -EX: 
            this.checkoutForm = formBuilder.group({
                emailAddr: ['', [Validators.minLength(5), Validators.maxLength(10), Validators.required, Validators.email],
                quantity: ['', Validators.required],
                terms: ['', Validators.requiredTrue],
                items: this.formBuilder.array([
                    new FormControl('HI'),
                    new FormControl('HELLO'),
                    new FormControl('LEARNING'),
                    new FormControl('CODING')
                ])
            })

-----------------------------------------------------------------------
Tutorial #45:  Reactive Forms -- Nested Form Array
-----------------------------------------------------------------------

1. 